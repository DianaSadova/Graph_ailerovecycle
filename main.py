graph = {
    1: [2, 72],
    2: [1, 3, 70,72],
    3: [2, 4,6,70],
    4: [3, 5,7,71],
    5: [4, 6, 69,71],
    6: [3, 5,7,72],
    7: [4, 6,8,51],
    8: [7, 9, 67,69],
    9: [8, 10,66,68],
    10: [9, 11,18,65],
    11: [10, 12, 17,25],
    12: [11, 13,16,17],
    13: [12, 14,16,25],
    14: [13, 15],
    15: [14, 16],
    16: [12, 13,15,17],
    17: [11, 12, 16,18],
    18: [10, 17,19,66],
    19: [18, 20,23,25],
    20: [19, 21],
    21: [20, 22,23,24],
    22: [21, 23],
    23: [19, 21, 22,24],
    24: [21, 23,25,68],
    25: [11, 13,19, 24,26, 67],
    26: [25, 27, 62,65],
    27: [26, 28,52,63],
    28: [27, 29,63, 64],
    29: [28, 30, 50,61],
    30: [29, 31,39,62],
    31: [30, 32,37, 64],
    32: [31, 33, 34,37],
    33: [32, 34],
    34: [32, 33,35,36],
    35: [34, 36],
    36: [34, 35,37,38],
    37: [31, 32,36, 38],
    38: [36, 37, 39,40],
    39: [30, 38,40,51],
    40: [38, 39,41,50],
    41: [40, 42, 47,48],
    42: [41, 43,44,47],
    43: [42, 44],
    44: [42, 43,45,46],
    45: [44, 46],
    46: [44, 45,47,48],
    47: [41, 42,46,48],
    48: [41, 46,47,49],
    49: [48, 50],
    50: [29, 40, 49,51],
    51: [7, 39,50,52],
    52: [27, 51,53,59],
    53: [52, 54, 58,61],
    54: [53, 55],
    55: [54,56],
    56: [55, 57, 58,59],
    57: [56, 58],
    58: [53, 56, 57, 59],
    59: [52, 56, 58,60],
    60: [59, 61],
    61: [29, 53, 60, 62],
    62: [26, 30, 61,63],
    63: [27, 28,62,64],
    64: [28, 31,63,65],
    65: [10, 26, 64,66],
    66: [9, 18,65,67],
    67: [8, 25,66,68],
    68: [9, 24, 67,69],
    69: [5, 8,68,70],
    70: [2, 3,69,71],
    71: [4, 5, 70,72],
    72: [1, 2,6,71]
}

# Проверяем все ли вершины имеют четную степень
def is_eulerian(graph):
    for edges in graph.values():
        if len(edges) % 2 != 0:
            return False
    return True

def find_eulerian_cycle(graph, start):
    if not is_eulerian(graph):
        return None

    # Копируем граф, чтобы не изменять оригинал
    graph_copy = {node: edges[:] for node, edges in graph.items()}
    cycle = []  # для хранения найденного цикла
    stack = [start]  # для реализации алгоритма обхода в глубину

    while stack:
        current = stack[-1]
        if graph_copy[current]:  # Если у текущей вершины есть смежные вершины
            next_node = graph_copy[current].pop()  # Берем случайное ребро
            graph_copy[next_node].remove(current)  # Удаляем обратное ребро
            stack.append(next_node)  # Добавляем следующую вершину в стек
        else:  # Если у текущей вершины нет смежных вершин
            cycle.append(stack.pop())  # Добавляем текущую вершину в цикл и удаляем её из стека

    return cycle[::-1]  # Возвращаем цикл в правильном порядке

    # Заданный граф
    # Ввод начальной вершины от пользователя
start_vertex = int(input("Введите начальную вершину (1-72): "))

# Находим Эйлеров цикл
eulerian_cycle = find_eulerian_cycle(graph, start_vertex)

# Вывод результата
if eulerian_cycle:
    print("Эйлеров цикл:", eulerian_cycle)
else:
    print("Эйлеров цикл не существует.")
